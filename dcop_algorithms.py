# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19xY_I89IZ_w0oahZNY-DaSjVdFZNLRyJ

# קוד IOT
"""

# קוד סימולציה ל-DSA, MGM ו-MGM-2
# DCOP Simulation Framework with DSA, MGM, and MGM-2
import random
import numpy as np
from collections import defaultdict
from abc import ABC, abstractmethod
import matplotlib.pyplot as plt

# ----- הגדרות קבועות לסימולציה -----
NUM_AGENTS   = 30    # מספר הסוכנים ברשת
DOMAIN_SIZE  = 5     # גודל התחום של כל סוכן
MAX_ITER     = 120   # מספר האיטרציות בכל הרצה
NUM_RUNS     = 30    # מספר הבעיות ההתחלתיות להרצה
P_VALUES     = [0.2, 0.7, 1.0]  # ערכי p ל-DSA

# ----- מערכת הדואר -----
# אחראית על העברת הודעות (ערכים ורווחים) בין הסוכנים
class MailSystem:
    def __init__(self):
        self.mail  = {}   # אחסון ערכי current_value
        self.gains = {}   # אחסון רווחים מחושבים

    def collect_messages(self, agents):
        # שלב א': איסוף הודעות ערכים מכל הסוכנים
        self.mail  = {a.id: a.send_message() for a in agents}

    def collect_gains(self, agents):
        # שלב ב': איסוף רווחים מכל הסוכנים
        self.gains = {a.id: a.get_gain() if hasattr(a, 'get_gain') else 0 for a in agents}

    def deliver_messages(self, agent_id, neighbors):
        # שליחת הערכים לשכנים
        return {nid: self.mail[nid] for nid in neighbors if nid in self.mail}

    def deliver_gains(self, agent_id, neighbors):
        # שליחת הרווחים לשכנים
        return {nid: self.gains[nid] for nid in neighbors if nid in self.gains}

# ----- פונקציות עזר -----
# יצירת שכנים, עלויות גלובליות וחישוב כלל העלות

def generate_neighbors(k):
    # יצירת גרף שכנים רנדומלי לפי צפיפות k
    neighbors = defaultdict(set)
    for i in range(NUM_AGENTS):
        for j in range(i+1, NUM_AGENTS):
            if random.random() < k:
                neighbors[i].add(j)
                neighbors[j].add(i)
    return neighbors


def generate_costs(neighbors):
    # יצירת מטריצות עלות אקראיות לכל זוג שכנים
    costs = {}
    for i in range(NUM_AGENTS):
        for j in neighbors[i]:
            if (j,i) not in costs:
                costs[(i,j)] = np.random.randint(100,201,(DOMAIN_SIZE,DOMAIN_SIZE))
    return costs


def calc_global_cost(assignments, costs):
    # חישוב העלות הגלובלית לפי ההשמות והעלויות
    return sum(
        matrix[assignments[i]][assignments[j]]
        for (i,j), matrix in costs.items()
    )

# ----- מחלקת סוכן אבסטרקטית ויורשיה -----
# AbstractAgent מגדיר ממשק בסיסי לסוכנים השונים
class AbstractAgent(ABC):
    def __init__(self, aid, domain, p):
        self.id            = aid
        self.domain        = domain
        self.current_value = random.choice(domain)  # השמה התחלתית רנדומלית
        self.neighbors     = set()
        self.inbox         = {}  # הערכים המתקבלים מהשכנים
        self.inbox_gains   = {}  # הרווחים המתקבלים מהשכנים
        self.p             = p
        self.costs         = {}  # פונקציות עלות מול כל שכן

    def set_cost_function(self, nid, cm):
        self.costs[nid] = cm

    def send_message(self):
        # החזרת ההשמה הנוכחית לשכנים
        return self.current_value

    def receive_messages(self, msgs):
        # קבלה ועדכון תיבות ההודעות
        if 'values' in msgs:
            self.inbox       = msgs['values']
        if 'gains'  in msgs:
            self.inbox_gains = msgs['gains']

    def compute_cost(self, val, nbrs):
        # חישוב עלות מקומית עבור ערך val
        return sum(
            self.costs[nid][val][nbr_val]
            for nid, nbr_val in nbrs.items()
            if nid in self.costs
        )

    @abstractmethod
    def decide_next_value(self): pass

# סוכן DSA: מנסה לערוך בחירה אם יש שיפור ואקראיות לפי p
class DSAAgent(AbstractAgent):
    def decide_next_value(self):
        cur_cost = self.compute_cost(self.current_value, self.inbox)
        best_val, best_cost = self.current_value, cur_cost
        for v in self.domain:
            if v == self.current_value: continue
            c = self.compute_cost(v, self.inbox)
            if c < best_cost:
                best_cost, best_val = c, v
        if best_val != self.current_value and random.random() < self.p:
            self.current_value = best_val

# סוכן MGM: שלב הצעה וכל שתי איטרציות של התחייבות
class MGMAgent(AbstractAgent):
    def __init__(self, aid, domain, p):
        super().__init__(aid, domain, p)
        self.best_value = self.current_value
        self.gain       = 0

    def get_gain(self): return self.gain

    def compute_proposal(self):
        # שלב חישוב הצעה ושמירת הרווח
        cur_cost = self.compute_cost(self.current_value, self.inbox)
        best_val, best_cost = self.current_value, cur_cost
        for v in self.domain:
            if v == self.current_value: continue
            c = self.compute_cost(v, self.inbox)
            if c < best_cost:
                best_cost, best_val = c, v
        self.best_value = best_val
        self.gain       = cur_cost - best_cost

    def commit_update(self):
        # שלב התחייבות אם הרווח הכי גבוה
        if self.gain > 0 and self.gain > max(self.inbox_gains.values(), default=-1):
            self.current_value = self.best_value

    def decide_next_value(self): pass

# סוכן MGM-2: התחייבות כל חמש איטרציות (gain>=)
class MGM2Agent(MGMAgent):
    def commit_update(self):
        if self.gain > 0 and self.gain >= max(self.inbox_gains.values(), default=-1):
            self.current_value = self.best_value

    def decide_next_value(self): pass

# ----- יצירת בעיות והרצה עליהם -----
# generate_problem_instances עם seed קבוע לניתנות לשחזור
def generate_problem_instances(k):
    random.seed(42)
    np.random.seed(42)
    problems = []
    for _ in range(NUM_RUNS):
        nbrs  = generate_neighbors(k)
        costs = generate_costs(nbrs)
        inits = [random.choice(range(DOMAIN_SIZE)) for _ in range(NUM_AGENTS)]
        problems.append((nbrs, costs, inits))
    return problems

# הרצת אלגוריתם על כל מופעי הבעיות
def run_on_problems(problems, p_value, agent_type):
    results = np.zeros((NUM_RUNS, MAX_ITER+1))
    for run, (nbrs, costs, inits) in enumerate(problems):
        # יצירת סוכנים לפי הסוג הנבחר
        if   agent_type=='DSA':
            agents = [DSAAgent(i, list(range(DOMAIN_SIZE)), p_value) for i in range(NUM_AGENTS)]
        elif agent_type=='MGM':
            agents = [MGMAgent(i, list(range(DOMAIN_SIZE)), p_value) for i in range(NUM_AGENTS)]
        else:
            agents = [MGM2Agent(i, list(range(DOMAIN_SIZE)), p_value) for i in range(NUM_AGENTS)]
        # הגדרת שכנים והשמות התחלתיות
        for a in agents:
            a.neighbors     = nbrs[a.id]
            a.current_value = inits[a.id]
        # קביעת פונקציות עלות לכל זוג
        for (i,j), mat in costs.items():
            agents[i].set_cost_function(j, mat)
            agents[j].set_cost_function(i, mat.T)

        init_assigns = [a.current_value for a in agents]
        results[run, 0] = calc_global_cost(init_assigns, costs)

        # לולאה עיקרית של iterations
        for t in range(1, MAX_ITER+1):
            mail = MailSystem()
            mail.collect_messages(agents)
            # שלב קבלת ערכים והחלטה על הערך הבא
            for a in agents:
                a.receive_messages({'values': mail.deliver_messages(a.id, a.neighbors)})
                if isinstance(a, DSAAgent):
                    a.decide_next_value()
                elif isinstance(a, MGMAgent):
                    if not isinstance(a, MGM2Agent) and t % 2 == 0:
                        a.compute_proposal()
                    elif isinstance(a, MGM2Agent) and t % 5 == 0:
                        a.compute_proposal()
            mail.collect_gains(agents)
            # שלב קבלת רווחים והתחייבות לשינוי
            for a in agents:
                if isinstance(a, DSAAgent): continue
                a.receive_messages({'gains': mail.deliver_gains(a.id, a.neighbors)})
                if not isinstance(a, MGM2Agent) and t % 2 == 0:
                    a.commit_update()
                elif isinstance(a, MGM2Agent) and t % 5 == 0:
                    a.commit_update()
            assigns = [a.current_value for a in agents]
            results[run, t] = calc_global_cost(assigns, costs)
    return results

# ----- ציור גרפים: השוואת האלגוריתמים -----
def plot_all_algorithms(k, domain_override=None):
    global DOMAIN_SIZE
    backup = DOMAIN_SIZE
    if domain_override is not None:
        DOMAIN_SIZE = domain_override

    problems = generate_problem_instances(k)
    data = {f"DSA-p={p}": run_on_problems(problems, p, 'DSA') for p in P_VALUES}
    data["MGM"]   = run_on_problems(problems, 1.0, 'MGM')
    data["MGM-2"] = run_on_problems(problems, 1.0, 'MGM2')

    plt.figure(figsize=(10,6))
    x = np.arange(MAX_ITER+1)
    for label, results in data.items():
        y = np.mean(results, axis=0)
        if label in ("MGM", "MGM-2"):
            plt.step(x, y, where='post', label=label)
        else:
            plt.plot(x, y, label=label)
    plt.xlabel("Iterations")
    plt.ylabel("Global Cost")
    plt.title(f"Comparison: DSA, MGM, MGM-2 (k={k})")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    DOMAIN_SIZE = backup

# נקודת כניסה להרצת התכנית
if __name__ == "__main__":
    plot_all_algorithms(k=0.25)
    plot_all_algorithms(k=0.75)
    plot_all_algorithms(k=0.1, domain_override=3)